<!DOCTYPE html>
<html lang="en">
  <head>
    
      <title>
        Exercises in assembly: recursion ::
        trevor mckay
      </title>
    
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta
  name="description"
  content="Trying to implement a recursive algorithm in assembly is both a challenging puzzle and very informative exercise to demonstrate some important properties of recursion and function calls in general.
Recursion Recursion is super important for writing clean and concise solutions to a whole subset of programming tasks. That&amp;rsquo;s not to say it&amp;rsquo;s without its drawbacks.
Some problems can be solved both iteratively and recursively. Due to the way a computer works—specifically the stack—the recursive solution often produces less efficient code."
/>
<meta
  name="keywords"
  content="blog, posts, portfolio, development, coding"
/>
<meta name="robots" content="noodp" />
<link rel="canonical" href="/posts/fib_asm/" />





<link rel="stylesheet" href="/assets/style.css" />

<link rel="stylesheet" href="/style.css" />


<link
  rel="apple-touch-icon-precomposed"
  sizes="144x144"
  href="/img/apple-touch-icon-144-precomposed.png"
/>
<link rel="shortcut icon" href="/img/favicon.png" />


<link href="/assets/fonts/Inter-Italic.woff2" rel="preload" type="font/woff2" as="font" crossorigin="">
<link href="/assets/fonts/Inter-Regular.woff2" rel="preload" type="font/woff2" as="font" crossorigin="">
<link href="/assets/fonts/Inter-Medium.woff2" rel="preload" type="font/woff2" as="font" crossorigin="">
<link href="/assets/fonts/Inter-MediumItalic.woff2" rel="preload" type="font/woff2" as="font" crossorigin="">
<link href="/assets/fonts/Inter-Bold.woff2" rel="preload" type="font/woff2" as="font" crossorigin="">
<link href="/assets/fonts/Inter-BoldItalic.woff2" rel="preload" type="font/woff2" as="font" crossorigin="">


<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Exercises in assembly: recursion"/>
<meta name="twitter:description" content="Trying to implement a recursive algorithm in assembly is both a challenging puzzle and very informative exercise to demonstrate some important properties of recursion and function calls in general.
Recursion Recursion is super important for writing clean and concise solutions to a whole subset of programming tasks. That&rsquo;s not to say it&rsquo;s without its drawbacks.
Some problems can be solved both iteratively and recursively. Due to the way a computer works—specifically the stack—the recursive solution often produces less efficient code."/>



<meta property="og:title" content="Exercises in assembly: recursion" />
<meta property="og:description" content="Trying to implement a recursive algorithm in assembly is both a challenging puzzle and very informative exercise to demonstrate some important properties of recursion and function calls in general.
Recursion Recursion is super important for writing clean and concise solutions to a whole subset of programming tasks. That&rsquo;s not to say it&rsquo;s without its drawbacks.
Some problems can be solved both iteratively and recursively. Due to the way a computer works—specifically the stack—the recursive solution often produces less efficient code." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/fib_asm/" />
<meta property="article:published_time" content="2021-01-31T18:48:09-08:00" />
<meta property="article:modified_time" content="2021-01-31T18:48:09-08:00" /><meta property="og:site_name" content="trevor mckay" />






  </head>
  <body class="dark-theme">
    <div class="container">
      <header class="header">
  <span class="header__inner">
    <a
  href="/"
  class="logo"
  style="text-decoration: none;"
>
  
    <span class="logo__mark"><svg xmlns="http://www.w3.org/2000/svg" class="greater-icon" viewBox="0 0 44 44">
  <path fill="none" d="M15 8l14.729 14.382L15 35.367" />
</svg>
</span>
    <span class="logo__text"
      >/home/trevor_mckay </span
    >
    <span class="logo__cursor"></span>
  
</a>

    <span class="header__right">
      
        <nav class="menu">
  <ul class="menu__inner menu__inner--desktop">
    
      
        
          <li><a href="/about">About</a></li>
        
      
        
          <li><a href="https://github.com/trmckay">GitHub</a></li>
        
      
        
          <li><a href="https://www.linkedin.com/in/trevor-mckay-1602a5180/">LinkedIn</a></li>
        
      
        
          <li><a href="/posts">Posts</a></li>
        
      
      
      
  </ul>

  <ul class="menu__inner menu__inner--mobile">
    
      
        <li><a href="/about">About</a></li>
      
    
      
        <li><a href="https://github.com/trmckay">GitHub</a></li>
      
    
      
        <li><a href="https://www.linkedin.com/in/trevor-mckay-1602a5180/">LinkedIn</a></li>
      
    
      
        <li><a href="/posts">Posts</a></li>
      
    
  </ul>
</nav>

        <span class="menu-trigger">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M0 0h24v24H0z" fill="none" />
            <path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z" />
          </svg>
        </span>
      
      <span class="theme-toggle">
        <svg
  class="theme-toggler"
  width="24"
  height="24"
  viewBox="0 0 48 48"
  fill="none"
  xmlns="http://www.w3.org/2000/svg"
>
  <path
    d="M22 41C32.4934 41 41 32.4934 41 22C41 11.5066 32.4934 3 22
  3C11.5066 3 3 11.5066 3 22C3 32.4934 11.5066 41 22 41ZM7 22C7
  13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22Z"
  />
</svg>

      </span>
    </span>
  </span>
  
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-178435018-1', 'auto');
	
	ga('send', 'pageview');
}
</script>

  
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-178435018-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

</header>


      <div class="content">
        
  
  

  <div class="post">
    <h1 class="post-title">Exercises in assembly: recursion</h1>
    <div class="post-meta">
      
        <span class="post-date">
          2021-01-31
        </span>

        
          
        
      

      


      
    </div>

    

    

    <div class="post-content">
      
      <p>Trying to implement a recursive algorithm in assembly is both a challenging puzzle
and very informative exercise to demonstrate some important properties
of recursion and function calls in general.</p>
<h1 id="recursion">Recursion</h1>
<p>Recursion is super important for writing clean and concise solutions
to a whole subset of programming tasks. That&rsquo;s not to say it&rsquo;s without
its drawbacks.</p>
<p>Some problems can be solved both iteratively and recursively. Due to the
way a computer works—specifically the stack—the recursive solution often
produces <em>less efficient</em> code.</p>
<p>Each time a new function is called, the CPU has to allocate a new stack frame,
a section of memory that belongs to the new function call. Usually this
involves saving a bunch of registers to the stack. The reverse is performed
as the function exits.</p>
<pre><code>------------------

    Caller's
    stack frame

------------------

    Fn(0)

------------------

    ...

------------------

    Fn(n-1)

__________________

    Fn(n)

------------------
                        Stack grows down
    ...
                               |
------------------             v
</code></pre><p>Depending on the architecture of your CPU, the stack memory is probably cached
unless you have a very deep call-stack, so this is less of a problem with
shallow recursion, especially if your algorithm does not frequently access
dynamic memory.</p>
<h1 id="fibonacci">Fibonacci</h1>
<p>Let&rsquo;s take a look at this in practice with a function that calculates
the <code>n</code>th number of the Fibonacci sequence.</p>
<p>You have maybe seen a function like this to perform that task:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">fib</span>(<span style="color:#66d9ef">int</span> n) {
    <span style="color:#66d9ef">if</span> (n <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">1</span>)
        <span style="color:#66d9ef">return</span> n;
    <span style="color:#66d9ef">else</span>
        <span style="color:#66d9ef">return</span> fib(n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">+</span> fib(n <span style="color:#f92672">-</span> <span style="color:#ae81ff">2</span>);
}
</code></pre></div><p>This solution is borderline trivial once one has a grasp of recursion.</p>
<p>The amount of work done by the compiler is drastically understated by the text.
Especially this line:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">return</span> <span style="color:#a6e22e">fib</span>(n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">+</span> fib(n <span style="color:#f92672">-</span> <span style="color:#ae81ff">2</span>);
</code></pre></div><p>The compiler needs to:</p>
<ul>
<li>Make two function calls, where each:
<ul>
<li>Saves all temporary registers to the stack.</li>
<li>Decrements the stack pointer.</li>
<li>Jumps to the program count of the function.</li>
<li>Pops the temporary registers and return address from the stack.</li>
</ul>
</li>
<li>Combine each result into a single result.</li>
<li>Deallocate the current scope&rsquo;s stack frame.</li>
<li>Jump to the return address.</li>
</ul>
<p>That&rsquo;s a lot of information packed into just a few characters. Implementing <code>fib</code> in
assembly may start to seem a little daunting given this understanding. But don&rsquo;t worry!
If you take it slow and take advantage of abstractions the same way a high-level
language like C does, it is very possible.</p>
<h1 id="black-box-model-of-the-function">Black-box model of the function</h1>
<p>Let&rsquo;s take a look at what our function is expected to do.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">/* Arguments: n = Which Fibonacci number to calculate
</span><span style="color:#75715e"> * Returns:   fib(n) = The nth Fibonacci number */</span>
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">fib</span>(<span style="color:#66d9ef">int</span> n);
</code></pre></div><p>This is simple enough. Give an <code>int</code>, get an <code>int</code>.</p>
<p>Lets translate this into assembly. I&rsquo;m going to use RISC-V assembly for the
purposes of this post.</p>
<p>There&rsquo;s some preliminary assembly info we need first. The RISC-V ABI says that
arguments go into the <code>a0</code>-<code>a7</code> registers. The same is true for return values.
Additionally, functions (generally referred to as subroutines in the context of
assembly) are prefixed with a label (like <code>FIB</code>) so they can be jumped/branched to.</p>
<p>With this is mind we should define our <code>FIB</code> subroutine like this:</p>
<pre><code># a0 &lt;- fib(n)
# Arguments: a0 = n
# Returns:   fib(n) in a0
FIB:
</code></pre><p>Notice there&rsquo;s not a single instruction here. We just have a label and some
commented assumptions our function makes. Unlike when writing a function
signature in C, we have no compiler to enforce type compatibility or calling
conventions. So, all we do is give our program counter somewhere to jump to.</p>
<h1 id="planning-the-structure">Planning the structure</h1>
<p>Before we start writing any more assembly, it would benefit us to plan out our
approach a little bit.</p>
<p>First off, there is going to be some preliminary work that our subroutine only
needs to do once. This includes pushing some registers onto the stack. Since
inflating the stack infinitely is widely considered bad manners, we don&rsquo;t want to
include this in the recursive part of the function.</p>
<p>With our next revision we won&rsquo;t much code, but we can narrow down the structure
a bit more.</p>
<pre><code># a0 &lt;- fib(n)
# Arguments: a0 = n
# Returns:   fib(n) in a0
FIB:
    # Save some registers to the stack.

    # Call the recursive helper routine, _R_FIB
    call         _R_FIB

    # Pop from the stack.

    ret

    # Helper subroutine.
    # Does the actual calculating, no stack manipulation.
    # a0 &lt;- fib(a0)
    _R_FIB:
        # Calculate fib(n) into a0
        ret
</code></pre><p><code>_R_FIB</code> has the same side effects as <code>FIB</code>, except it does not do any unnecessary
stack manipulation.</p>
<p>Also, we have added two important instructions here who&rsquo;s behavior is crucial to
understanding the later parts of the program.</p>
<ul>
<li><code>call</code>: This instruction jumps to the given label and saves the next program
count as the return address.</li>
<li><code>ret</code>: This instruction jumps to the return address.</li>
</ul>
<p>The return address is stored in a named register (<code>ra</code>). Each time we use <code>call</code> we
are overwriting this register. Because of this, we need to make sure we are saving
the return address to the stack each time we <code>call</code> a subroutine.</p>
<p>Let&rsquo;s have this be our first real addition to our subroutine. Again, before we
<code>call _R_FIB</code> we need to save the return address. To do this we need to understand
the stack pointer. The stack pointer (<code>sp</code> in RISC-V) is another special register
that stores the memory address of the bottom of the stack. Loading from the address
in the stack pointer register is equivalent to popping from the stack.</p>
<p>Some architectures have built in instructions for pushing and popping, but RISC-V does
not. So we will implement this functionality with a combination of loads/stores and
addition/subtraction to the <code>sp</code> register.</p>
<p>Further looking at the C-version of our algorithm, you would deduce that we are
going to checking &lt;=1 frequently. We can save an instruction by keeping this in a
saved register. This is one more register we need to save to the stack when our
subroutine is called.</p>
<pre><code>FIB:
    addi    sp,  sp, -8    # Decrement by 8 because each register is 4 bytes.
    sw      s0,  0(sp)     # Push s0 to stack.
    sw      ra,  4(sp)     # Push return address to stack.

    call         _R_FIB

    lw      ra,  4(sp)     # Pop return address from stack.
    lw      s0,  0(sp)     # Pop s0 from stack.
    addi    sp, sp, 8      #

    ret

    _R_FIB:
        ret
</code></pre><p>We are beginning to see some of the overhead that goes into each function call.
Those pushes and pops can add up.</p>
<h1 id="fleshing-out-the-recursive-helper">Fleshing out the recursive helper</h1>
<p>This sub-subroutine is going to be the potato stew of our program. About 75% of
our subroutine consists of assembly that corresponds to the line I pointed out
earlier. Restated here, that line is:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">return</span> <span style="color:#a6e22e">fib</span>(n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">+</span> fib(n <span style="color:#f92672">-</span> <span style="color:#ae81ff">2</span>);
</code></pre></div><p>Before writing any more assembly, we can actually benefit from breaking this
apart into a few more lines of C. Something like this:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">temp1 <span style="color:#f92672">=</span> fib(n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>);
result <span style="color:#f92672">=</span> fib(n <span style="color:#f92672">-</span> <span style="color:#ae81ff">2</span>);
result <span style="color:#f92672">+=</span> temp1;
<span style="color:#66d9ef">return</span> result;
</code></pre></div><p>This is less readable at a glance, but its corresponding assembly functionally
equivalent (and likely identical) to what we had before.</p>
<p>I write it like this because this allows us to glean the structure of our recursive
helper routine. It&rsquo;s now obvious that it should:</p>
<ol>
<li>Calculate <code>fib(n - 1)</code> and hang on to it.</li>
<li>Calculate <code>fib(n - 2)</code>.</li>
<li>Add them together.</li>
<li>Return the result.</li>
</ol>
<p>For the first two, we will leverage the abstractions that subroutines and functions
allow us to build.</p>
<p>We also should not forget to check for a base case.</p>
<p>Let&rsquo;s revisit some assembly. Here we are just looking at the recursive part. Keep
in mind, there are several issues with this still.</p>
<pre><code># a0 &lt;- fib(n)
# Arguments: a0 = n
# Returns:   a0 = fib(n)
_R_FIB:
    # We need a base case that jumps to EXIT.

    # fib(n - 1)
    # Set a0 equal to n - 1.
    addi    a0,  a0, -1
    # We assume this puts fib(a0) in a0.
    call         _R_FIB

    # Hang on to fib(n - 1).
    mv      t0,  a0

    # fib(n - 2)
    # Set a0 equal to n - 2.
    # We can't actually do this since n - 1 was
    # overwritten with the return value from the
    # first _R_FIB call.
    # But, let's assume we get n - 1 back into
    # a0 somehow.
    # Set a0 equal to n - 2.
    addi    a0,  a0, -1
    call         _R_FIB

    # a0 &lt;- fib(n - 1) + fib(n - 2)
    add     a0,  a0, t0

    EXIT: ret
</code></pre><p>Let&rsquo;s discuss the simplest issue first: the base case. For Fibonacci, this
is simply <code>fib(0) = 0</code> and <code>fib(1) = 1</code>.</p>
<p>If we load 2 into our saved register <code>s0</code> at the beginning of the subroutine,
we can use a branch-if-less-than instruction, i.e. <code>blt a0, s0, EXIT</code>.</p>
<p>The more troublesome issue is dealing with all the register interference that
the recursive calls will undoubtedly incur upon us.</p>
<p>Thinking back to the initial call of <code>_R_FIB</code> by the outer subroutine, we can
at least be sure that we need to push the return address onto the stack as
to not get lost.</p>
<p>For the <code>fib(n - 1)</code> call of <code>_R_FIB</code>, we should also save <code>a0</code> to the stack
so we can retrieve it and use its value for the <code>fib(n - 2)</code> call. Let&rsquo;s add
these instructions before the first call to save those values on the stack:</p>
<pre><code>addi    sp,  sp, -8    #
sw      ra,  4(sp)     # Don't forget the return address or you will get lost.
sw      a0,  0(sp)     # Push to the stack, preparing for a function call.
</code></pre><p>After our <code>fib(n - 1)</code> call exits and we move the result to <code>t0</code>, we can start
popping from the stack.</p>
<pre><code>lw      a0,  0(sp)     # Get a0 back by popping once from the stack.
addi    sp,  sp, 4     #
</code></pre><p>Also, we shouldn&rsquo;t pop the return address since we are about to make another
function call anyway.</p>
<p>For the second call we don&rsquo;t need to save <code>a0</code>; we are done with <code>n</code>. However,
there&rsquo;s one more thing we need to save. We just loaded a value into <code>t0</code>
and we are dependent on it staying there. If call <code>_R_FIB</code> again, it will
put <em>its own</em> value into <code>t0</code>. We can&rsquo;t lose our value when that happens,
so we have to push it onto the stack. Combining the push and pop it looks
like this:</p>
<pre><code>addi    sp,  sp, -4    #
sw      t0,  0(sp)     # Push t0 onto the stack.

call         _R_FIB    # fib(n-1) gets loaded into a0

lw      t0,  0(sp)     # Pop once for t0.
lw      ra,  4(sp)     # Once more for the return address.
addi    sp,  sp, 8
</code></pre><p>We are nearly done. We just need to add <code>fib(n - 1)</code> and <code>fib(n - 2)</code> together
and return.</p>
<p>We incorporate the add, base case, and loading 2 into the <code>s0</code> register to get
our finished subroutine.</p>
<pre><code># Arguments: a0: int = n
# Returns:   a0: int = fib(n)
# Summary:   a0 &lt;- fib(a0)
FIB:
    # We only need two registers for this subroutine.
    addi    sp,  sp, -8    #
    sw      s0,  0(sp)     # Push s0 to stack.
    sw      ra,  4(sp)     # Push return address to stack.

    li      s0,  2         # 2 will be used for a conditional.

    # a0 &lt;- fib(a0)
    call         _R_FIB    # Call recursive helper function.

    lw      ra,  4(sp)     # Pop return address from stack.
    lw      s0,  0(sp)     # Pop s0 from stack.
    addi    sp,  sp, 8     #

    ret

    _R_FIB:
        # This is the exit condition.
        # If a0 &lt; 2, return a0.
        # fib(0) = 0 &amp; fib(1) = 1
        blt     a0,  s0, EXIT

        # fib(n - 1)
        #############################################################################
        addi    a0,  a0, -1    # a0 &lt;- a0 - 1

        addi    sp,  sp, -8    #
        sw      ra,  4(sp)     # Don't forget the return address or you will get lost.
        sw      a0,  0(sp)     # Push to the stack, preparing for a function call.

        call         _R_FIB    # fib(a0 - 1) gets loaded into a0.

        mv      t0,  a0        # Save result of fib(n-1) in t0, we need it later.

        lw      a0,  0(sp)     # Get a0 back by popping once from the stack.
        addi    sp,  sp, 4     #
        #############################################################################

        # Note: t0 contains fib(n-1) and a0 contains n-1.

        # fib(n - 2)
        #############################################################################
        addi    a0,  a0, -1    # a0 &lt;- a0 - 1

        addi    sp,  sp, -4    #
        sw      t0,  0(sp)     # Push t0 onto the stack.

        call         _R_FIB    # fib(n-1) gets loaded into a0

        lw      t0,  0(sp)     # Pop once for t0.
        lw      ra,  4(sp)     # Once more for the return address.
        addi    sp,  sp, 8     #
        #############################################################################

        # At this point, a0 = fib(n-2) and t0 = fib(n-1)

        add     a0, a0, t0     #
        EXIT: ret              # return fib(n - 1) + fib(n - 2)
</code></pre><p>Not too bad when you break it down piece by piece. But, it certainly helps give
an appreciation for the amount of headache compilers save us.</p>
<h1 id="a-look-at-the-iterative-version">A look at the iterative version</h1>
<p>Now that we&rsquo;ve done this the hard way, let&rsquo;s take a look at the better approach.
Here is the same function but programmed iteratively.</p>
<pre><code># Arguments: a0: int = n
# Returns:   a0: int = fib(n)
# Summary:   a0 &lt;- fib(a0)
FIB:
    addi    sp,  sp, -4    #
    sw      s0,  4(sp)     # Push s0 to the stack.

    li      s0,  s0, 2     # Constant used for comparisons.

    blt     a0,  s0, EXIT  # If n &lt; 2, then fib(n) = n.

    li      t0,  1    # Initialize N.
    li      t1,  1    # fib(1) = 1
    li      t2,  0    # fib(0) = 0

    LOOP:
         addi,   t0,  t0, 1       # Increment counter.
         mv      t3,  t1          # Save fib(n-1) in temporary register.
         add     t1,  t1, t2      # fib(n-1)[next] &lt;- fib(n-1)[curr] + fib(n-2)[curr]
         mv      t2,  t3          # fib(n-2)[next] &lt;- fib(n-1)[curr]
         blt     t0,  a0, LOOP    # Loop again if counter &lt; n.

    mv      a0,  t1    # Move fib(n-1)[next] = fib(n)[curr] into return register.
    EXIT:   ret        # Return.
</code></pre><p>It&rsquo;s more readable in my opinion. It has more going for
it than that, though.</p>
<ul>
<li>It has next to no memory accesses.</li>
<li>It has fewer <em>static</em> instructions (more on this in a second).</li>
<li>It&rsquo;s not vulnerable to a stack overflow for large values of <code>n</code>.</li>
</ul>
<p>It&rsquo;s difficult for me to come up with any advantages of the recursive
version other than it looks good in a high-level language. The most I can
say is that the difference in size is not as important as it seems at
first glance. Sure, the iterative version has fewer static instructions and
will therefore save you some space in your binary. But, as far as dynamic instructions
go, they&rsquo;ll be on the same order of magnitude.</p>
<p>What really hurts the recursive version is its excessive memory access. This is really
the key lesson to be learned from this exercise. This subroutine succinctly
demonstrates the overhead that is inherent to recursion and even function calls
in general. That&rsquo;s something to consider when writing recursive algorithms in the future.
Is your cache going to save you? Or will you suffer miss after miss, piling on 100s of
nanoseconds per call?</p>

    </div>
    
      
        <div class="pagination">
          <div class="pagination__title">
            <span class="pagination__title-h"
              >Read other posts</span
            >
            <hr />
          </div>
          <div class="pagination__buttons">
            
            
              <span class="button next">
                <a href="/posts/rsync-anacron-backups/">
                  <span class="button__text">Automated backups with _rsync_, _anacron_, and the cloud</span>
                  <span class="button__icon">→</span>
                </a>
              </span>
            
          </div>
        </div>
      
    

    
      
        

      
    
  </div>

      </div>

      
        <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright copyright--user">© 2021 Trevor McKay</div>
      
  </div>
</footer>

<script src="/assets/main.js"></script>
<script src="/assets/prism.js"></script>


      
    </div>

    
      
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-178435018-1', 'auto');
	
	ga('send', 'pageview');
}
</script>

    
  </body>
</html>
