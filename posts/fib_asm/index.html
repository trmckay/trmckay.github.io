<!DOCTYPE html>
<html><head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <title>Exercises in assembly: recursion</title>
    <meta name="description" content="Landing page for my interests">
    <meta name="author" content='Trevor McKay'>

    <link href="https://fonts.googleapis.com/css2?family=Inconsolata:wght@400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" integrity="sha384-TX8t27EcRE3e/ihU7zmQxVncDAy5uIKz4rEkgIXeMed4M0jlfIDPvg6uqKI2xXr2" crossorigin="anonymous">

    
    <link rel="stylesheet" href="/sass/researcher.min.css">

    

    
        
    
</head>

    <body><div class="container mt-5">
    <nav class="navbar navbar-expand-sm flex-column flex-sm-row text-nowrap p-0">
        <a class="navbar-brand mx-0 mr-sm-auto" href="https://www.trmckay.com">
          
          Trevor McKay
        </a>
        <div class="navbar-nav flex-row flex-wrap justify-content-center">
            
                
                
                    <a class="nav-item nav-link" href="/posts">
                        Posts
                    </a>
                    
                        <span class="nav-item navbar-text mx-1">/</span>
                    
                
                    <a class="nav-item nav-link" href="/trmckay_resume.pdf">
                        Resume
                    </a>
                    
                
            
        </div>
    </nav>
</div>
<hr>
<div id="content">
<div class="container">
    <p>Trying to implement a recursive algorithm in assembly is both a challenging puzzle
and very informative exercise to demonstrate some important properties
of recursion and function calls in general.</p>
<h1 id="recursion">Recursion</h1>
<p>Recursion is super important for writing clean and concise solutions
to a whole subset of programming tasks. That&rsquo;s not to say it&rsquo;s without
its drawbacks.</p>
<p>Some problems can be solved both iteratively and recursively. Due to the
way a computer works—specifically the stack—the recursive solution often
produces <em>less efficient</em> code.</p>
<p>Each time a new function is called, the CPU has to allocate a new stack frame,
a section of memory that belongs to the new function call. Usually this
involves saving a bunch of registers to the stack. The reverse is performed
as the function exits.</p>
<pre><code>------------------

    Caller's
    stack frame

------------------

    Fn(0)

------------------

    ...

------------------

    Fn(n-1)

__________________

    Fn(n)

------------------
                        Stack grows down
    ...
                               |
------------------             v
</code></pre><p>Depending on the architecture of your CPU, the stack memory is probably cached
unless you have a very deep call-stack, so this is less of a problem with
shallow recursion, especially if your algorithm does not frequently access
dynamic memory.</p>
<h1 id="fibonacci">Fibonacci</h1>
<p>Let&rsquo;s take a look at this in practice with a function that calculates
the <code>n</code>th number of the Fibonacci sequence.</p>
<p>You have maybe seen a function like this to perform that task:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">fib</span>(<span style="color:#66d9ef">int</span> n) {
    <span style="color:#66d9ef">if</span> (n <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">1</span>)
        <span style="color:#66d9ef">return</span> n;
    <span style="color:#66d9ef">else</span>
        <span style="color:#66d9ef">return</span> fib(n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">+</span> fib(n <span style="color:#f92672">-</span> <span style="color:#ae81ff">2</span>);
}
</code></pre></div><p>This solution is borderline trivial once one has a grasp of recursion.</p>
<p>The amount of work done by the compiler is drastically understated by the text.
Especially this line:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">return</span> <span style="color:#a6e22e">fib</span>(n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">+</span> fib(n <span style="color:#f92672">-</span> <span style="color:#ae81ff">2</span>);
</code></pre></div><p>The compiler needs to:</p>
<ul>
<li>Make two function calls, where each:
<ul>
<li>Saves all temporary registers to the stack.</li>
<li>Decrements the stack pointer.</li>
<li>Jumps to the program count of the function.</li>
<li>Pops the temporary registers and return address from the stack.</li>
</ul>
</li>
<li>Combine each result into a single result.</li>
<li>Deallocate the current scope&rsquo;s stack frame.</li>
<li>Jump to the return address.</li>
</ul>
<p>That&rsquo;s a lot of information packed into just a few characters. Implementing <code>fib</code> in
assembly may start to seem a little daunting given this understanding. But don&rsquo;t worry!
If you take it slow and take advantage of abstractions the same way a high-level
language like C does, it is very possible.</p>
<h1 id="black-box-model-of-the-function">Black-box model of the function</h1>
<p>Let&rsquo;s take a look at what our function is expected to do.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">/* Arguments: n = Which Fibonacci number to calculate
</span><span style="color:#75715e"> * Returns:   fib(n) = The nth Fibonacci number */</span>
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">fib</span>(<span style="color:#66d9ef">int</span> n);
</code></pre></div><p>This is simple enough. Give an <code>int</code>, get an <code>int</code>.</p>
<p>Lets translate this into assembly. I&rsquo;m going to use RISC-V assembly for the
purposes of this post.</p>
<p>There&rsquo;s some preliminary assembly info we need first. The RISC-V ABI says that
arguments go into the <code>a0</code>-<code>a7</code> registers. The same is true for return values.
Additionally, functions (generally referred to as subroutines in the context of
assembly) are prefixed with a label (like <code>FIB</code>) so they can be jumped/branched to.</p>
<p>With this is mind we should define our <code>FIB</code> subroutine like this:</p>
<pre><code># a0 &lt;- fib(n)
# Arguments: a0 = n
# Returns:   fib(n) in a0
FIB:
</code></pre><p>Notice there&rsquo;s not a single instruction here. We just have a label and some
commented assumptions our function makes. Unlike when writing a function
signature in C, we have no compiler to enforce type compatibility or calling
conventions. So, all we do is give our program counter somewhere to jump to.</p>
<h1 id="planning-the-structure">Planning the structure</h1>
<p>Before we start writing any more assembly, it would benefit us to plan out our
approach a little bit.</p>
<p>First off, there is going to be some preliminary work that our subroutine only
needs to do once. This includes pushing some registers onto the stack. Since
inflating the stack infinitely is widely considered bad manners, we don&rsquo;t want to
include this in the recursive part of the function.</p>
<p>With our next revision we won&rsquo;t much code, but we can narrow down the structure
a bit more.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-asm" data-lang="asm"><span style="color:#75715e"># a0 &lt;- fib(n)
</span><span style="color:#75715e"># Arguments: a0 = n
</span><span style="color:#75715e"># Returns:   fib(n) in a0
</span><span style="color:#75715e"></span>FIB:
    <span style="color:#75715e"># Save some registers to the stack.
</span><span style="color:#75715e"></span>
    <span style="color:#75715e"># Call the recursive helper routine, _R_FIB
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">call</span>         <span style="color:#66d9ef">_R_FIB</span>

    <span style="color:#75715e"># Pop from the stack.
</span><span style="color:#75715e"></span>
    <span style="color:#a6e22e">ret</span>

    <span style="color:#75715e"># Helper subroutine.
</span><span style="color:#75715e"></span>    <span style="color:#75715e"># Does the actual calculating, no stack manipulation.
</span><span style="color:#75715e"></span>    <span style="color:#75715e"># a0 &lt;- fib(a0)
</span><span style="color:#75715e"></span>    _R_FIB:
        <span style="color:#75715e"># Calculate fib(n) into a0
</span><span style="color:#75715e"></span>        <span style="color:#a6e22e">ret</span>
</code></pre></div><p><code>_R_FIB</code> has the same side effects as <code>FIB</code>, except it does not do any unnecessary
stack manipulation.</p>
<p>Also, we have added two important instructions here who&rsquo;s behavior is crucial to
understanding the later parts of the program.</p>
<ul>
<li><code>call</code>: This instruction jumps to the given label and saves the next program
count as the return address.</li>
<li><code>ret</code>: This instruction jumps to the return address.</li>
</ul>
<p>The return address is stored in a named register (<code>ra</code>). Each time we use <code>call</code> we
are overwriting this register. Because of this, we need to make sure we are saving
the return address to the stack each time we <code>call</code> a subroutine.</p>
<p>Let&rsquo;s have this be our first real addition to our subroutine. Again, before we
<code>call _R_FIB</code> we need to save the return address. To do this we need to understand
the stack pointer. The stack pointer (<code>sp</code> in RISC-V) is another special register
that stores the memory address of the bottom of the stack. Loading from the address
in the stack pointer register is equivalent to popping from the stack.</p>
<p>Some architectures have built in instructions for pushing and popping, but RISC-V does
not. So we will implement this functionality with a combination of loads/stores and
addition/subtraction to the <code>sp</code> register.</p>
<p>Further looking at the C-version of our algorithm, you would deduce that we are
going to checking &lt;=1 frequently. We can save an instruction by keeping this in a
saved register. This is one more register we need to save to the stack when our
subroutine is called.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-asm" data-lang="asm">FIB:
    <span style="color:#a6e22e">addi</span>    <span style="color:#66d9ef">sp</span>,  <span style="color:#66d9ef">sp</span>, -<span style="color:#ae81ff">8</span>    <span style="color:#75715e"># Decrement by 8 because each register is 4 bytes.
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">sw</span>      <span style="color:#66d9ef">s0</span>,  <span style="color:#ae81ff">0</span>(<span style="color:#66d9ef">sp</span>)     <span style="color:#75715e"># Push s0 to stack.
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">sw</span>      <span style="color:#66d9ef">ra</span>,  <span style="color:#ae81ff">4</span>(<span style="color:#66d9ef">sp</span>)     <span style="color:#75715e"># Push return address to stack.
</span><span style="color:#75715e"></span>
    <span style="color:#a6e22e">call</span>         <span style="color:#66d9ef">_R_FIB</span>

    <span style="color:#a6e22e">lw</span>      <span style="color:#66d9ef">ra</span>,  <span style="color:#ae81ff">4</span>(<span style="color:#66d9ef">sp</span>)     <span style="color:#75715e"># Pop return address from stack.
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">lw</span>      <span style="color:#66d9ef">s0</span>,  <span style="color:#ae81ff">0</span>(<span style="color:#66d9ef">sp</span>)     <span style="color:#75715e"># Pop s0 from stack.
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">addi</span>    <span style="color:#66d9ef">sp</span>, <span style="color:#66d9ef">sp</span>, <span style="color:#ae81ff">8</span>      <span style="color:#75715e">#
</span><span style="color:#75715e"></span>
    <span style="color:#a6e22e">ret</span>

    _R_FIB:
        <span style="color:#a6e22e">ret</span>
</code></pre></div><p>We are beginning to see some of the overhead that goes into each function call.
Those pushes and pops can add up.</p>
<h1 id="fleshing-out-the-recursive-helper">Fleshing out the recursive helper</h1>
<p>This sub-subroutine is going to be the potato stew of our program. About 75% of
our subroutine consists of assembly that corresponds to the line I pointed out
earlier. Restated here, that line is:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">return</span> <span style="color:#a6e22e">fib</span>(n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">+</span> fib(n <span style="color:#f92672">-</span> <span style="color:#ae81ff">2</span>);
</code></pre></div><p>Before writing any more assembly, we can actually benefit from breaking this
apart into a few more lines of C. Something like this:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">temp1 <span style="color:#f92672">=</span> fib(n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>);
result <span style="color:#f92672">=</span> fib(n <span style="color:#f92672">-</span> <span style="color:#ae81ff">2</span>);
result <span style="color:#f92672">+=</span> temp1;
<span style="color:#66d9ef">return</span> result;
</code></pre></div><p>This is less readable at a glance, but its corresponding assembly functionally
equivalent (and likely identical) to what we had before.</p>
<p>I write it like this because this allows us to glean the structure of our recursive
helper routine. It&rsquo;s now obvious that it should:</p>
<ol>
<li>Calculate <code>fib(n - 1)</code> and hang on to it.</li>
<li>Calculate <code>fib(n - 2)</code>.</li>
<li>Add them together.</li>
<li>Return the result.</li>
</ol>
<p>For the first two, we will leverage the abstractions that subroutines and functions
allow us to build.</p>
<p>We also should not forget to check for a base case.</p>
<p>Let&rsquo;s revisit some assembly. Here we are just looking at the recursive part. Keep
in mind, there are several issues with this still.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-asm" data-lang="asm"><span style="color:#75715e"># a0 &lt;- fib(n)
</span><span style="color:#75715e"># Arguments: a0 = n
</span><span style="color:#75715e"># Returns:   a0 = fib(n)
</span><span style="color:#75715e"></span>_R_FIB:
    <span style="color:#75715e"># We need a base case that jumps to EXIT.
</span><span style="color:#75715e"></span>
    <span style="color:#75715e"># fib(n - 1)
</span><span style="color:#75715e"></span>    <span style="color:#75715e"># Set a0 equal to n - 1.
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">addi</span>    <span style="color:#66d9ef">a0</span>,  <span style="color:#66d9ef">a0</span>, -<span style="color:#ae81ff">1</span>
    <span style="color:#75715e"># We assume this puts fib(a0) in a0.
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">call</span>         <span style="color:#66d9ef">_R_FIB</span>

    <span style="color:#75715e"># Hang on to fib(n - 1).
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">mv</span>      <span style="color:#66d9ef">t0</span>,  <span style="color:#66d9ef">a0</span>

    <span style="color:#75715e"># fib(n - 2)
</span><span style="color:#75715e"></span>    <span style="color:#75715e"># Set a0 equal to n - 2.
</span><span style="color:#75715e"></span>    <span style="color:#75715e"># We can&#39;t actually do this since n - 1 was
</span><span style="color:#75715e"></span>    <span style="color:#75715e"># overwritten with the return value from the
</span><span style="color:#75715e"></span>    <span style="color:#75715e"># first _R_FIB call.
</span><span style="color:#75715e"></span>    <span style="color:#75715e"># But, let&#39;s assume we get n - 1 back into
</span><span style="color:#75715e"></span>    <span style="color:#75715e"># a0 somehow.
</span><span style="color:#75715e"></span>    <span style="color:#75715e"># Set a0 equal to n - 2.
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">addi</span>    <span style="color:#66d9ef">a0</span>,  <span style="color:#66d9ef">a0</span>, -<span style="color:#ae81ff">1</span>
    <span style="color:#a6e22e">call</span>         <span style="color:#66d9ef">_R_FIB</span>

    <span style="color:#75715e"># a0 &lt;- fib(n - 1) + fib(n - 2)
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">add</span>     <span style="color:#66d9ef">a0</span>,  <span style="color:#66d9ef">a0</span>, <span style="color:#66d9ef">t0</span>

    EXIT: <span style="color:#a6e22e">ret</span>
</code></pre></div><p>Let&rsquo;s discuss the simplest issue first: the base case. For Fibonacci, this
is simply <code>fib(0) = 0</code> and <code>fib(1) = 1</code>.</p>
<p>If we load 2 into our saved register <code>s0</code> at the beginning of the subroutine,
we can use a branch-if-less-than instruction, i.e. <code>blt a0, s0, EXIT</code>.</p>
<p>The more troublesome issue is dealing with all the register interference that
the recursive calls will undoubtedly incur upon us.</p>
<p>Thinking back to the initial call of <code>_R_FIB</code> by the outer subroutine, we can
at least be sure that we need to push the return address onto the stack as
to not get lost.</p>
<p>For the <code>fib(n - 1)</code> call of <code>_R_FIB</code>, we should also save <code>a0</code> to the stack
so we can retrieve it and use its value for the <code>fib(n - 2)</code> call. Let&rsquo;s add
these instructions before the first call to save those values on the stack:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-asm" data-lang="asm"><span style="color:#a6e22e">addi</span>    <span style="color:#66d9ef">sp</span>,  <span style="color:#66d9ef">sp</span>, -<span style="color:#ae81ff">8</span>    <span style="color:#75715e">#
</span><span style="color:#75715e"></span><span style="color:#66d9ef">sw</span>      <span style="color:#66d9ef">ra</span>,  <span style="color:#ae81ff">4</span>(<span style="color:#66d9ef">sp</span>)     <span style="color:#75715e"># Don&#39;t forget the return address or you will get lost.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">sw</span>      <span style="color:#66d9ef">a0</span>,  <span style="color:#ae81ff">0</span>(<span style="color:#66d9ef">sp</span>)     <span style="color:#75715e"># Push to the stack, preparing for a function call.
</span></code></pre></div><p>After our <code>fib(n - 1)</code> call exits and we move the result to <code>t0</code>, we can start
popping from the stack.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-asm" data-lang="asm"><span style="color:#a6e22e">lw</span>      <span style="color:#66d9ef">a0</span>,  <span style="color:#ae81ff">0</span>(<span style="color:#66d9ef">sp</span>)     <span style="color:#75715e"># Get a0 back by popping once from the stack.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">addi</span>    <span style="color:#66d9ef">sp</span>,  <span style="color:#66d9ef">sp</span>, <span style="color:#ae81ff">4</span>     <span style="color:#75715e">#
</span></code></pre></div><p>Also, we shouldn&rsquo;t pop the return address since we are about to make another
function call anyway.</p>
<p>For the second call we don&rsquo;t need to save <code>a0</code>; we are done with <code>n</code>. However,
there&rsquo;s one more thing we need to save. We just loaded a value into <code>t0</code>
and we are dependent on it staying there. If call <code>_R_FIB</code> again, it will
put <em>its own</em> value into <code>t0</code>. We can&rsquo;t lose our value when that happens,
so we have to push it onto the stack. Combining the push and pop it looks
like this:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-asm" data-lang="asm"><span style="color:#a6e22e">addi</span>    <span style="color:#66d9ef">sp</span>,  <span style="color:#66d9ef">sp</span>, -<span style="color:#ae81ff">4</span>    <span style="color:#75715e">#
</span><span style="color:#75715e"></span><span style="color:#66d9ef">sw</span>      <span style="color:#66d9ef">t0</span>,  <span style="color:#ae81ff">0</span>(<span style="color:#66d9ef">sp</span>)     <span style="color:#75715e"># Push t0 onto the stack.
</span><span style="color:#75715e"></span>
<span style="color:#a6e22e">call</span>         <span style="color:#66d9ef">_R_FIB</span>    <span style="color:#75715e"># fib(n-1) gets loaded into a0
</span><span style="color:#75715e"></span>
<span style="color:#a6e22e">lw</span>      <span style="color:#66d9ef">t0</span>,  <span style="color:#ae81ff">0</span>(<span style="color:#66d9ef">sp</span>)     <span style="color:#75715e"># Pop once for t0.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">lw</span>      <span style="color:#66d9ef">ra</span>,  <span style="color:#ae81ff">4</span>(<span style="color:#66d9ef">sp</span>)     <span style="color:#75715e"># Once more for the return address.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">addi</span>    <span style="color:#66d9ef">sp</span>,  <span style="color:#66d9ef">sp</span>, <span style="color:#ae81ff">8</span>
</code></pre></div><p>We are nearly done. We just need to add <code>fib(n - 1)</code> and <code>fib(n - 2)</code> together
and return.</p>
<p>We incorporate the add, base case, and loading 2 into the <code>s0</code> register to get
our finished subroutine.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-asm" data-lang="asm"><span style="color:#75715e"># Arguments: a0: int = n
</span><span style="color:#75715e"># Returns:   a0: int = fib(n)
</span><span style="color:#75715e"># Summary:   a0 &lt;- fib(a0)
</span><span style="color:#75715e"></span>FIB:
    <span style="color:#75715e"># We only need two registers for this subroutine.
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">addi</span>    <span style="color:#66d9ef">sp</span>,  <span style="color:#66d9ef">sp</span>, -<span style="color:#ae81ff">8</span>    <span style="color:#75715e">#
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">sw</span>      <span style="color:#66d9ef">s0</span>,  <span style="color:#ae81ff">0</span>(<span style="color:#66d9ef">sp</span>)     <span style="color:#75715e"># Push s0 to stack.
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">sw</span>      <span style="color:#66d9ef">ra</span>,  <span style="color:#ae81ff">4</span>(<span style="color:#66d9ef">sp</span>)     <span style="color:#75715e"># Push return address to stack.
</span><span style="color:#75715e"></span>
    <span style="color:#a6e22e">li</span>      <span style="color:#66d9ef">s0</span>,  <span style="color:#ae81ff">2</span>         <span style="color:#75715e"># 2 will be used for a conditional.
</span><span style="color:#75715e"></span>
    <span style="color:#75715e"># a0 &lt;- fib(a0)
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">call</span>         <span style="color:#66d9ef">_R_FIB</span>    <span style="color:#75715e"># Call recursive helper function.
</span><span style="color:#75715e"></span>
    <span style="color:#a6e22e">lw</span>      <span style="color:#66d9ef">ra</span>,  <span style="color:#ae81ff">4</span>(<span style="color:#66d9ef">sp</span>)     <span style="color:#75715e"># Pop return address from stack.
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">lw</span>      <span style="color:#66d9ef">s0</span>,  <span style="color:#ae81ff">0</span>(<span style="color:#66d9ef">sp</span>)     <span style="color:#75715e"># Pop s0 from stack.
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">addi</span>    <span style="color:#66d9ef">sp</span>,  <span style="color:#66d9ef">sp</span>, <span style="color:#ae81ff">8</span>     <span style="color:#75715e">#
</span><span style="color:#75715e"></span>
    <span style="color:#a6e22e">ret</span>

    _R_FIB:
        <span style="color:#75715e"># This is the exit condition.
</span><span style="color:#75715e"></span>        <span style="color:#75715e"># If a0 &lt; 2, return a0.
</span><span style="color:#75715e"></span>        <span style="color:#75715e"># fib(0) = 0 &amp; fib(1) = 1
</span><span style="color:#75715e"></span>        <span style="color:#a6e22e">blt</span>     <span style="color:#66d9ef">a0</span>,  <span style="color:#66d9ef">s0</span>, <span style="color:#66d9ef">EXIT</span>

        <span style="color:#75715e"># fib(n - 1)
</span><span style="color:#75715e"></span>        <span style="color:#75715e">#############################################################################
</span><span style="color:#75715e"></span>        <span style="color:#a6e22e">addi</span>    <span style="color:#66d9ef">a0</span>,  <span style="color:#66d9ef">a0</span>, -<span style="color:#ae81ff">1</span>    <span style="color:#75715e"># a0 &lt;- a0 - 1
</span><span style="color:#75715e"></span>
        <span style="color:#a6e22e">addi</span>    <span style="color:#66d9ef">sp</span>,  <span style="color:#66d9ef">sp</span>, -<span style="color:#ae81ff">8</span>    <span style="color:#75715e">#
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">sw</span>      <span style="color:#66d9ef">ra</span>,  <span style="color:#ae81ff">4</span>(<span style="color:#66d9ef">sp</span>)     <span style="color:#75715e"># Don&#39;t forget the return address or you will get lost.
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">sw</span>      <span style="color:#66d9ef">a0</span>,  <span style="color:#ae81ff">0</span>(<span style="color:#66d9ef">sp</span>)     <span style="color:#75715e"># Push to the stack, preparing for a function call.
</span><span style="color:#75715e"></span>
        <span style="color:#a6e22e">call</span>         <span style="color:#66d9ef">_R_FIB</span>    <span style="color:#75715e"># fib(a0 - 1) gets loaded into a0.
</span><span style="color:#75715e"></span>
        <span style="color:#a6e22e">mv</span>      <span style="color:#66d9ef">t0</span>,  <span style="color:#66d9ef">a0</span>        <span style="color:#75715e"># Save result of fib(n-1) in t0, we need it later.
</span><span style="color:#75715e"></span>
        <span style="color:#a6e22e">lw</span>      <span style="color:#66d9ef">a0</span>,  <span style="color:#ae81ff">0</span>(<span style="color:#66d9ef">sp</span>)     <span style="color:#75715e"># Get a0 back by popping once from the stack.
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">addi</span>    <span style="color:#66d9ef">sp</span>,  <span style="color:#66d9ef">sp</span>, <span style="color:#ae81ff">4</span>     <span style="color:#75715e">#
</span><span style="color:#75715e"></span>        <span style="color:#75715e">#############################################################################
</span><span style="color:#75715e"></span>
        <span style="color:#75715e"># Note: t0 contains fib(n-1) and a0 contains n-1.
</span><span style="color:#75715e"></span>
        <span style="color:#75715e"># fib(n - 2)
</span><span style="color:#75715e"></span>        <span style="color:#75715e">#############################################################################
</span><span style="color:#75715e"></span>        <span style="color:#a6e22e">addi</span>    <span style="color:#66d9ef">a0</span>,  <span style="color:#66d9ef">a0</span>, -<span style="color:#ae81ff">1</span>    <span style="color:#75715e"># a0 &lt;- a0 - 1
</span><span style="color:#75715e"></span>
        <span style="color:#a6e22e">addi</span>    <span style="color:#66d9ef">sp</span>,  <span style="color:#66d9ef">sp</span>, -<span style="color:#ae81ff">4</span>    <span style="color:#75715e">#
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">sw</span>      <span style="color:#66d9ef">t0</span>,  <span style="color:#ae81ff">0</span>(<span style="color:#66d9ef">sp</span>)     <span style="color:#75715e"># Push t0 onto the stack.
</span><span style="color:#75715e"></span>
        <span style="color:#a6e22e">call</span>         <span style="color:#66d9ef">_R_FIB</span>    <span style="color:#75715e"># fib(n-1) gets loaded into a0
</span><span style="color:#75715e"></span>
        <span style="color:#a6e22e">lw</span>      <span style="color:#66d9ef">t0</span>,  <span style="color:#ae81ff">0</span>(<span style="color:#66d9ef">sp</span>)     <span style="color:#75715e"># Pop once for t0.
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">lw</span>      <span style="color:#66d9ef">ra</span>,  <span style="color:#ae81ff">4</span>(<span style="color:#66d9ef">sp</span>)     <span style="color:#75715e"># Once more for the return address.
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">addi</span>    <span style="color:#66d9ef">sp</span>,  <span style="color:#66d9ef">sp</span>, <span style="color:#ae81ff">8</span>     <span style="color:#75715e">#
</span><span style="color:#75715e"></span>        <span style="color:#75715e">#############################################################################
</span><span style="color:#75715e"></span>
        <span style="color:#75715e"># At this point, a0 = fib(n-2) and t0 = fib(n-1)
</span><span style="color:#75715e"></span>
        <span style="color:#a6e22e">add</span>     <span style="color:#66d9ef">a0</span>, <span style="color:#66d9ef">a0</span>, <span style="color:#66d9ef">t0</span>     <span style="color:#75715e">#
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">EXIT</span>: <span style="color:#66d9ef">ret</span>              <span style="color:#75715e"># return fib(n - 1) + fib(n - 2)
</span></code></pre></div><p>Not too bad when you break it down piece by piece. But, it certainly helps give
an appreciation for the amount of headache compilers save us.</p>
<h1 id="a-look-at-the-iterative-version">A look at the iterative version</h1>
<p>Now that we&rsquo;ve done this the hard way, let&rsquo;s take a look at the better approach.
Here is the same function but programmed iteratively.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-asm" data-lang="asm"><span style="color:#75715e"># Arguments: a0: int = n
</span><span style="color:#75715e"># Returns:   a0: int = fib(n)
</span><span style="color:#75715e"># Summary:   a0 &lt;- fib(a0)
</span><span style="color:#75715e"></span>FIB:
    <span style="color:#a6e22e">addi</span>    <span style="color:#66d9ef">sp</span>,  <span style="color:#66d9ef">sp</span>, -<span style="color:#ae81ff">4</span>    <span style="color:#75715e">#
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">sw</span>      <span style="color:#66d9ef">s0</span>,  <span style="color:#ae81ff">4</span>(<span style="color:#66d9ef">sp</span>)     <span style="color:#75715e"># Push s0 to the stack.
</span><span style="color:#75715e"></span>
    <span style="color:#a6e22e">li</span>      <span style="color:#66d9ef">s0</span>,  <span style="color:#66d9ef">s0</span>, <span style="color:#ae81ff">2</span>     <span style="color:#75715e"># Constant used for comparisons.
</span><span style="color:#75715e"></span>
    <span style="color:#a6e22e">blt</span>     <span style="color:#66d9ef">a0</span>,  <span style="color:#66d9ef">s0</span>, <span style="color:#66d9ef">EXIT</span>  <span style="color:#75715e"># If n &lt; 2, then fib(n) = n.
</span><span style="color:#75715e"></span>
    <span style="color:#a6e22e">li</span>      <span style="color:#66d9ef">t0</span>,  <span style="color:#ae81ff">1</span>    <span style="color:#75715e"># Initialize N.
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">li</span>      <span style="color:#66d9ef">t1</span>,  <span style="color:#ae81ff">1</span>    <span style="color:#75715e"># fib(1) = 1
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">li</span>      <span style="color:#66d9ef">t2</span>,  <span style="color:#ae81ff">0</span>    <span style="color:#75715e"># fib(0) = 0
</span><span style="color:#75715e"></span>
    LOOP:
         <span style="color:#a6e22e">addi</span>,   <span style="color:#66d9ef">t0</span>,  <span style="color:#66d9ef">t0</span>, <span style="color:#ae81ff">1</span>       <span style="color:#75715e"># Increment counter.
</span><span style="color:#75715e"></span>         <span style="color:#66d9ef">mv</span>      <span style="color:#66d9ef">t3</span>,  <span style="color:#66d9ef">t1</span>          <span style="color:#75715e"># Save fib(n-1) in temporary register.
</span><span style="color:#75715e"></span>         <span style="color:#66d9ef">add</span>     <span style="color:#66d9ef">t1</span>,  <span style="color:#66d9ef">t1</span>, <span style="color:#66d9ef">t2</span>      <span style="color:#75715e"># fib(n-1)[next] &lt;- fib(n-1)[curr] + fib(n-2)[curr]
</span><span style="color:#75715e"></span>         <span style="color:#66d9ef">mv</span>      <span style="color:#66d9ef">t2</span>,  <span style="color:#66d9ef">t3</span>          <span style="color:#75715e"># fib(n-2)[next] &lt;- fib(n-1)[curr]
</span><span style="color:#75715e"></span>         <span style="color:#66d9ef">blt</span>     <span style="color:#66d9ef">t0</span>,  <span style="color:#66d9ef">a0</span>, <span style="color:#66d9ef">LOOP</span>    <span style="color:#75715e"># Loop again if counter &lt; n.
</span><span style="color:#75715e"></span>
    <span style="color:#a6e22e">mv</span>      <span style="color:#66d9ef">a0</span>,  <span style="color:#66d9ef">t1</span>    <span style="color:#75715e"># Move fib(n-1)[next] = fib(n)[curr] into return register.
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">EXIT</span>:   <span style="color:#66d9ef">ret</span>        <span style="color:#75715e"># Return.
</span></code></pre></div><p>It&rsquo;s more readable in my opinion. It has more going for
it than that, though.</p>
<ul>
<li>It has next to no memory accesses.</li>
<li>It has fewer <em>static</em> instructions (more on this in a second).</li>
<li>It&rsquo;s not vulnerable to a stack overflow for large values of <code>n</code>.</li>
</ul>
<p>It&rsquo;s difficult for me to come up with any advantages of the recursive
version other than it looks good in a high-level language. The most I can
say is that the difference in size is not as important as it seems at
first glance. Sure, the iterative version has fewer static instructions and
will therefore save you some space in your binary. But, as far as dynamic instructions
go, they&rsquo;ll be on the same order of magnitude.</p>
<p>What really hurts the recursive version is its excessive memory access. This is really
the key lesson to be learned from this exercise. This subroutine succinctly
demonstrates the overhead that is inherent to recursion and even function calls
in general. That&rsquo;s something to consider when writing recursive algorithms in the future.
Is your cache going to save you? Or will you suffer miss after miss, piling on 100s of
nanoseconds per call?</p>

</div>

        </div><div id="footer" class="mb-5">
    
        <hr>
        <div class="container text-center">
            <a href="https://www.trmckay.com"><small>copyright 2021 Trevor McKay</small></a>
        </div>
    
</div>
</body>
</html>
