<!DOCTYPE html>
<html><head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="your description">
    <meta name="Author" content="Trevor McKay">
    <meta name="keywords" content="hugo blog">
    <link rel="stylesheet" href=https://www.trmckay.com/css/syntax.css>
    <link rel="stylesheet" href=https://www.trmckay.com/css/style.css>
    <script src="https://kit.fontawesome.com/1b7478c139.js" crossorigin="anonymous"></script>
    <title>Trevor McKay</title>
  </head><body><aside id="sidenav">
    <header>
    

    <a id="branding" href=https://www.trmckay.com>
        
            Trevor McKay
        
    </a>
    </header>

    <nav>
        
            		
            <a href="/"
                
            >
                <i class="fas fa-home fa-sm"></i>
                <span>home</span>
            </a>
        
            		
            <a href="https://github.com/trmckay"
                
                    target="_blank"
                
            >
                <i class="fab fa-github fa-ms"></i>
                <span>github</span>
            </a>
        
            		
            <a href="/about"
                
            >
                <i class="far fa-envelope"></i>
                <span>about</span>
            </a>
        
    </nav>
</aside>
<main id="main">
            <div class="content">
    
    <h1 id="title">Exercises in assembly: recursion</h1>
    
      
    <nav id="TableOfContents"></nav>
    <p>Trying to implement a recursive algorithm in assembly is both a challenging puzzle
and very informative exercise to demonstrate some important properties
of recursion and function calls in general.</p>
<h1 id="recursion">Recursion</h1>
<p>Recursion is super important for writing clean and concise solutions
to a whole subset of programming tasks. That&rsquo;s not to say it&rsquo;s without
its drawbacks.</p>
<p>Some problems can be solved both iteratively and recursively. Due to the
way a computer works—specifically the stack—the recursive solution often
produces <em>less efficient</em> code.</p>
<p>Each time a new function is called, the CPU has to allocate a new stack frame,
a section of memory that belongs to the new function call. Usually this
involves saving a bunch of registers to the stack. The reverse is performed
as the function exits.</p>
<pre><code>------------------

    Caller's
    stack frame

------------------

    Fn(0)

------------------

    ...

------------------

    Fn(n-1)

__________________

    Fn(n)

------------------
                        Stack grows down
    ...
                               |
------------------             v
</code></pre><p>Depending on the architecture of your CPU, the stack memory is probably cached
unless you have a very deep call-stack, so this is less of a problem with
shallow recursion, especially if your algorithm does not frequently access
dynamic memory.</p>
<h1 id="fibonacci">Fibonacci</h1>
<p>Let&rsquo;s take a look at this in practice with a function that calculates
the <code>n</code>th number of the Fibonacci sequence.</p>
<p>You have maybe seen a function like this to perform that task:</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">fib</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">n</span><span class="p">;</span>
    <span class="k">else</span>
        <span class="k">return</span> <span class="n">fib</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">fib</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>This solution is borderline trivial once one has a grasp of recursion.</p>
<p>The amount of work done by the compiler is drastically understated by the text.
Especially this line:</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="k">return</span> <span class="nf">fib</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">fib</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">);</span>
</code></pre></div><p>The compiler needs to:</p>
<ul>
<li>Make two function calls, where each:
<ul>
<li>Saves all temporary registers to the stack.</li>
<li>Decrements the stack pointer.</li>
<li>Jumps to the program count of the function.</li>
<li>Pops the temporary registers and return address from the stack.</li>
</ul>
</li>
<li>Combine each result into a single result.</li>
<li>Deallocate the current scope&rsquo;s stack frame.</li>
<li>Jump to the return address.</li>
</ul>
<p>That&rsquo;s a lot of information packed into just a few characters. Implementing <code>fib</code> in
assembly may start to seem a little daunting given this understanding. But don&rsquo;t worry!
If you take it slow and take advantage of abstractions the same way a high-level
language like C does, it is very possible.</p>
<h1 id="black-box-model-of-the-function">Black-box model of the function</h1>
<p>Let&rsquo;s take a look at what our function is expected to do.</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* Arguments: n = Which Fibonacci number to calculate
</span><span class="cm"> * Returns:   fib(n) = The nth Fibonacci number */</span>
<span class="kt">int</span> <span class="nf">fib</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">);</span>
</code></pre></div><p>This is simple enough. Give an <code>int</code>, get an <code>int</code>.</p>
<p>Lets translate this into assembly. I&rsquo;m going to use RISC-V assembly for the
purposes of this post.</p>
<p>There&rsquo;s some preliminary assembly info we need first. The RISC-V ABI says that
arguments go into the <code>a0</code>-<code>a7</code> registers. The same is true for return values.
Additionally, functions (generally referred to as subroutines in the context of
assembly) are prefixed with a label (like <code>FIB</code>) so they can be jumped/branched to.</p>
<p>With this is mind we should define our <code>FIB</code> subroutine like this:</p>
<pre><code># a0 &lt;- fib(n)
# Arguments: a0 = n
# Returns:   fib(n) in a0
FIB:
</code></pre><p>Notice there&rsquo;s not a single instruction here. We just have a label and some
commented assumptions our function makes. Unlike when writing a function
signature in C, we have no compiler to enforce type compatibility or calling
conventions. So, all we do is give our program counter somewhere to jump to.</p>
<h1 id="planning-the-structure">Planning the structure</h1>
<p>Before we start writing any more assembly, it would benefit us to plan out our
approach a little bit.</p>
<p>First off, there is going to be some preliminary work that our subroutine only
needs to do once. This includes pushing some registers onto the stack. Since
inflating the stack infinitely is widely considered bad manners, we don&rsquo;t want to
include this in the recursive part of the function.</p>
<p>With our next revision we won&rsquo;t much code, but we can narrow down the structure
a bit more.</p>
<div class="highlight"><pre class="chroma"><code class="language-asm" data-lang="asm"><span class="c"># a0 &lt;- fib(n)
</span><span class="c"># Arguments: a0 = n
</span><span class="c"># Returns:   fib(n) in a0
</span><span class="c"></span><span class="nl">FIB:</span>
    <span class="c"># Save some registers to the stack.
</span><span class="c"></span>
    <span class="c"># Call the recursive helper routine, _R_FIB
</span><span class="c"></span>    <span class="nf">call</span>         <span class="no">_R_FIB</span>

    <span class="c"># Pop from the stack.
</span><span class="c"></span>
    <span class="nf">ret</span>

    <span class="c"># Helper subroutine.
</span><span class="c"></span>    <span class="c"># Does the actual calculating, no stack manipulation.
</span><span class="c"></span>    <span class="c"># a0 &lt;- fib(a0)
</span><span class="c"></span>    <span class="nl">_R_FIB:</span>
        <span class="c"># Calculate fib(n) into a0
</span><span class="c"></span>        <span class="nf">ret</span>
</code></pre></div><p><code>_R_FIB</code> has the same side effects as <code>FIB</code>, except it does not do any unnecessary
stack manipulation.</p>
<p>Also, we have added two important instructions here who&rsquo;s behavior is crucial to
understanding the later parts of the program.</p>
<ul>
<li><code>call</code>: This instruction jumps to the given label and saves the next program
count as the return address.</li>
<li><code>ret</code>: This instruction jumps to the return address.</li>
</ul>
<p>The return address is stored in a named register (<code>ra</code>). Each time we use <code>call</code> we
are overwriting this register. Because of this, we need to make sure we are saving
the return address to the stack each time we <code>call</code> a subroutine.</p>
<p>Let&rsquo;s have this be our first real addition to our subroutine. Again, before we
<code>call _R_FIB</code> we need to save the return address. To do this we need to understand
the stack pointer. The stack pointer (<code>sp</code> in RISC-V) is another special register
that stores the memory address of the bottom of the stack. Loading from the address
in the stack pointer register is equivalent to popping from the stack.</p>
<p>Some architectures have built in instructions for pushing and popping, but RISC-V does
not. So we will implement this functionality with a combination of loads/stores and
addition/subtraction to the <code>sp</code> register.</p>
<p>Further looking at the C-version of our algorithm, you would deduce that we are
going to checking &lt;=1 frequently. We can save an instruction by keeping this in a
saved register. This is one more register we need to save to the stack when our
subroutine is called.</p>
<div class="highlight"><pre class="chroma"><code class="language-asm" data-lang="asm"><span class="nl">FIB:</span>
    <span class="nf">addi</span>    <span class="no">sp</span><span class="p">,</span>  <span class="no">sp</span><span class="p">,</span> <span class="p">-</span><span class="mi">8</span>    <span class="c"># Decrement by 8 because each register is 4 bytes.
</span><span class="c"></span>    <span class="no">sw</span>      <span class="no">s0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">(</span><span class="no">sp</span><span class="p">)</span>     <span class="c"># Push s0 to stack.
</span><span class="c"></span>    <span class="no">sw</span>      <span class="no">ra</span><span class="p">,</span>  <span class="mi">4</span><span class="p">(</span><span class="no">sp</span><span class="p">)</span>     <span class="c"># Push return address to stack.
</span><span class="c"></span>
    <span class="nf">call</span>         <span class="no">_R_FIB</span>

    <span class="nf">lw</span>      <span class="no">ra</span><span class="p">,</span>  <span class="mi">4</span><span class="p">(</span><span class="no">sp</span><span class="p">)</span>     <span class="c"># Pop return address from stack.
</span><span class="c"></span>    <span class="no">lw</span>      <span class="no">s0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">(</span><span class="no">sp</span><span class="p">)</span>     <span class="c"># Pop s0 from stack.
</span><span class="c"></span>    <span class="no">addi</span>    <span class="no">sp</span><span class="p">,</span> <span class="no">sp</span><span class="p">,</span> <span class="mi">8</span>      <span class="c">#
</span><span class="c"></span>
    <span class="nf">ret</span>

    <span class="nl">_R_FIB:</span>
        <span class="nf">ret</span>
</code></pre></div><p>We are beginning to see some of the overhead that goes into each function call.
Those pushes and pops can add up.</p>
<h1 id="fleshing-out-the-recursive-helper">Fleshing out the recursive helper</h1>
<p>This sub-subroutine is going to be the potato stew of our program. About 75% of
our subroutine consists of assembly that corresponds to the line I pointed out
earlier. Restated here, that line is:</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="k">return</span> <span class="nf">fib</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">fib</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">);</span>
</code></pre></div><p>Before writing any more assembly, we can actually benefit from breaking this
apart into a few more lines of C. Something like this:</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">temp1</span> <span class="o">=</span> <span class="n">fib</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">fib</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">);</span>
<span class="n">result</span> <span class="o">+=</span> <span class="n">temp1</span><span class="p">;</span>
<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
</code></pre></div><p>This is less readable at a glance, but its corresponding assembly functionally
equivalent (and likely identical) to what we had before.</p>
<p>I write it like this because this allows us to glean the structure of our recursive
helper routine. It&rsquo;s now obvious that it should:</p>
<ol>
<li>Calculate <code>fib(n - 1)</code> and hang on to it.</li>
<li>Calculate <code>fib(n - 2)</code>.</li>
<li>Add them together.</li>
<li>Return the result.</li>
</ol>
<p>For the first two, we will leverage the abstractions that subroutines and functions
allow us to build.</p>
<p>We also should not forget to check for a base case.</p>
<p>Let&rsquo;s revisit some assembly. Here we are just looking at the recursive part. Keep
in mind, there are several issues with this still.</p>
<div class="highlight"><pre class="chroma"><code class="language-asm" data-lang="asm"><span class="c"># a0 &lt;- fib(n)
</span><span class="c"># Arguments: a0 = n
</span><span class="c"># Returns:   a0 = fib(n)
</span><span class="c"></span><span class="nl">_R_FIB:</span>
    <span class="c"># We need a base case that jumps to EXIT.
</span><span class="c"></span>
    <span class="c"># fib(n - 1)
</span><span class="c"></span>    <span class="c"># Set a0 equal to n - 1.
</span><span class="c"></span>    <span class="nf">addi</span>    <span class="no">a0</span><span class="p">,</span>  <span class="no">a0</span><span class="p">,</span> <span class="p">-</span><span class="mi">1</span>
    <span class="c"># We assume this puts fib(a0) in a0.
</span><span class="c"></span>    <span class="nf">call</span>         <span class="no">_R_FIB</span>

    <span class="c"># Hang on to fib(n - 1).
</span><span class="c"></span>    <span class="nf">mv</span>      <span class="no">t0</span><span class="p">,</span>  <span class="no">a0</span>

    <span class="c"># fib(n - 2)
</span><span class="c"></span>    <span class="c"># Set a0 equal to n - 2.
</span><span class="c"></span>    <span class="c"># We can&#39;t actually do this since n - 1 was
</span><span class="c"></span>    <span class="c"># overwritten with the return value from the
</span><span class="c"></span>    <span class="c"># first _R_FIB call.
</span><span class="c"></span>    <span class="c"># But, let&#39;s assume we get n - 1 back into
</span><span class="c"></span>    <span class="c"># a0 somehow.
</span><span class="c"></span>    <span class="c"># Set a0 equal to n - 2.
</span><span class="c"></span>    <span class="nf">addi</span>    <span class="no">a0</span><span class="p">,</span>  <span class="no">a0</span><span class="p">,</span> <span class="p">-</span><span class="mi">1</span>
    <span class="nf">call</span>         <span class="no">_R_FIB</span>

    <span class="c"># a0 &lt;- fib(n - 1) + fib(n - 2)
</span><span class="c"></span>    <span class="nf">add</span>     <span class="no">a0</span><span class="p">,</span>  <span class="no">a0</span><span class="p">,</span> <span class="no">t0</span>

    <span class="nl">EXIT:</span> <span class="nf">ret</span>
</code></pre></div><p>Let&rsquo;s discuss the simplest issue first: the base case. For Fibonacci, this
is simply <code>fib(0) = 0</code> and <code>fib(1) = 1</code>.</p>
<p>If we load 2 into our saved register <code>s0</code> at the beginning of the subroutine,
we can use a branch-if-less-than instruction, i.e. <code>blt a0, s0, EXIT</code>.</p>
<p>The more troublesome issue is dealing with all the register interference that
the recursive calls will undoubtedly incur upon us.</p>
<p>Thinking back to the initial call of <code>_R_FIB</code> by the outer subroutine, we can
at least be sure that we need to push the return address onto the stack as
to not get lost.</p>
<p>For the <code>fib(n - 1)</code> call of <code>_R_FIB</code>, we should also save <code>a0</code> to the stack
so we can retrieve it and use its value for the <code>fib(n - 2)</code> call. Let&rsquo;s add
these instructions before the first call to save those values on the stack:</p>
<div class="highlight"><pre class="chroma"><code class="language-asm" data-lang="asm"><span class="nf">addi</span>    <span class="no">sp</span><span class="p">,</span>  <span class="no">sp</span><span class="p">,</span> <span class="p">-</span><span class="mi">8</span>    <span class="c">#
</span><span class="c"></span><span class="no">sw</span>      <span class="no">ra</span><span class="p">,</span>  <span class="mi">4</span><span class="p">(</span><span class="no">sp</span><span class="p">)</span>     <span class="c"># Don&#39;t forget the return address or you will get lost.
</span><span class="c"></span><span class="no">sw</span>      <span class="no">a0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">(</span><span class="no">sp</span><span class="p">)</span>     <span class="c"># Push to the stack, preparing for a function call.
</span></code></pre></div><p>After our <code>fib(n - 1)</code> call exits and we move the result to <code>t0</code>, we can start
popping from the stack.</p>
<div class="highlight"><pre class="chroma"><code class="language-asm" data-lang="asm"><span class="nf">lw</span>      <span class="no">a0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">(</span><span class="no">sp</span><span class="p">)</span>     <span class="c"># Get a0 back by popping once from the stack.
</span><span class="c"></span><span class="no">addi</span>    <span class="no">sp</span><span class="p">,</span>  <span class="no">sp</span><span class="p">,</span> <span class="mi">4</span>     <span class="c">#
</span></code></pre></div><p>Also, we shouldn&rsquo;t pop the return address since we are about to make another
function call anyway.</p>
<p>For the second call we don&rsquo;t need to save <code>a0</code>; we are done with <code>n</code>. However,
there&rsquo;s one more thing we need to save. We just loaded a value into <code>t0</code>
and we are dependent on it staying there. If call <code>_R_FIB</code> again, it will
put <em>its own</em> value into <code>t0</code>. We can&rsquo;t lose our value when that happens,
so we have to push it onto the stack. Combining the push and pop it looks
like this:</p>
<div class="highlight"><pre class="chroma"><code class="language-asm" data-lang="asm"><span class="nf">addi</span>    <span class="no">sp</span><span class="p">,</span>  <span class="no">sp</span><span class="p">,</span> <span class="p">-</span><span class="mi">4</span>    <span class="c">#
</span><span class="c"></span><span class="no">sw</span>      <span class="no">t0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">(</span><span class="no">sp</span><span class="p">)</span>     <span class="c"># Push t0 onto the stack.
</span><span class="c"></span>
<span class="nf">call</span>         <span class="no">_R_FIB</span>    <span class="c"># fib(n-1) gets loaded into a0
</span><span class="c"></span>
<span class="nf">lw</span>      <span class="no">t0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">(</span><span class="no">sp</span><span class="p">)</span>     <span class="c"># Pop once for t0.
</span><span class="c"></span><span class="no">lw</span>      <span class="no">ra</span><span class="p">,</span>  <span class="mi">4</span><span class="p">(</span><span class="no">sp</span><span class="p">)</span>     <span class="c"># Once more for the return address.
</span><span class="c"></span><span class="no">addi</span>    <span class="no">sp</span><span class="p">,</span>  <span class="no">sp</span><span class="p">,</span> <span class="mi">8</span>
</code></pre></div><p>We are nearly done. We just need to add <code>fib(n - 1)</code> and <code>fib(n - 2)</code> together
and return.</p>
<p>We incorporate the add, base case, and loading 2 into the <code>s0</code> register to get
our finished subroutine.</p>
<div class="highlight"><pre class="chroma"><code class="language-asm" data-lang="asm"><span class="c"># Arguments: a0: int = n
</span><span class="c"># Returns:   a0: int = fib(n)
</span><span class="c"># Summary:   a0 &lt;- fib(a0)
</span><span class="c"></span><span class="nl">FIB:</span>
    <span class="c"># We only need two registers for this subroutine.
</span><span class="c"></span>    <span class="nf">addi</span>    <span class="no">sp</span><span class="p">,</span>  <span class="no">sp</span><span class="p">,</span> <span class="p">-</span><span class="mi">8</span>    <span class="c">#
</span><span class="c"></span>    <span class="no">sw</span>      <span class="no">s0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">(</span><span class="no">sp</span><span class="p">)</span>     <span class="c"># Push s0 to stack.
</span><span class="c"></span>    <span class="no">sw</span>      <span class="no">ra</span><span class="p">,</span>  <span class="mi">4</span><span class="p">(</span><span class="no">sp</span><span class="p">)</span>     <span class="c"># Push return address to stack.
</span><span class="c"></span>
    <span class="nf">li</span>      <span class="no">s0</span><span class="p">,</span>  <span class="mi">2</span>         <span class="c"># 2 will be used for a conditional.
</span><span class="c"></span>
    <span class="c"># a0 &lt;- fib(a0)
</span><span class="c"></span>    <span class="nf">call</span>         <span class="no">_R_FIB</span>    <span class="c"># Call recursive helper function.
</span><span class="c"></span>
    <span class="nf">lw</span>      <span class="no">ra</span><span class="p">,</span>  <span class="mi">4</span><span class="p">(</span><span class="no">sp</span><span class="p">)</span>     <span class="c"># Pop return address from stack.
</span><span class="c"></span>    <span class="no">lw</span>      <span class="no">s0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">(</span><span class="no">sp</span><span class="p">)</span>     <span class="c"># Pop s0 from stack.
</span><span class="c"></span>    <span class="no">addi</span>    <span class="no">sp</span><span class="p">,</span>  <span class="no">sp</span><span class="p">,</span> <span class="mi">8</span>     <span class="c">#
</span><span class="c"></span>
    <span class="nf">ret</span>

    <span class="nl">_R_FIB:</span>
        <span class="c"># This is the exit condition.
</span><span class="c"></span>        <span class="c"># If a0 &lt; 2, return a0.
</span><span class="c"></span>        <span class="c"># fib(0) = 0 &amp; fib(1) = 1
</span><span class="c"></span>        <span class="nf">blt</span>     <span class="no">a0</span><span class="p">,</span>  <span class="no">s0</span><span class="p">,</span> <span class="no">EXIT</span>

        <span class="c"># fib(n - 1)
</span><span class="c"></span>        <span class="c">#############################################################################
</span><span class="c"></span>        <span class="nf">addi</span>    <span class="no">a0</span><span class="p">,</span>  <span class="no">a0</span><span class="p">,</span> <span class="p">-</span><span class="mi">1</span>    <span class="c"># a0 &lt;- a0 - 1
</span><span class="c"></span>
        <span class="nf">addi</span>    <span class="no">sp</span><span class="p">,</span>  <span class="no">sp</span><span class="p">,</span> <span class="p">-</span><span class="mi">8</span>    <span class="c">#
</span><span class="c"></span>        <span class="no">sw</span>      <span class="no">ra</span><span class="p">,</span>  <span class="mi">4</span><span class="p">(</span><span class="no">sp</span><span class="p">)</span>     <span class="c"># Don&#39;t forget the return address or you will get lost.
</span><span class="c"></span>        <span class="no">sw</span>      <span class="no">a0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">(</span><span class="no">sp</span><span class="p">)</span>     <span class="c"># Push to the stack, preparing for a function call.
</span><span class="c"></span>
        <span class="nf">call</span>         <span class="no">_R_FIB</span>    <span class="c"># fib(a0 - 1) gets loaded into a0.
</span><span class="c"></span>
        <span class="nf">mv</span>      <span class="no">t0</span><span class="p">,</span>  <span class="no">a0</span>        <span class="c"># Save result of fib(n-1) in t0, we need it later.
</span><span class="c"></span>
        <span class="nf">lw</span>      <span class="no">a0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">(</span><span class="no">sp</span><span class="p">)</span>     <span class="c"># Get a0 back by popping once from the stack.
</span><span class="c"></span>        <span class="no">addi</span>    <span class="no">sp</span><span class="p">,</span>  <span class="no">sp</span><span class="p">,</span> <span class="mi">4</span>     <span class="c">#
</span><span class="c"></span>        <span class="c">#############################################################################
</span><span class="c"></span>
        <span class="c"># Note: t0 contains fib(n-1) and a0 contains n-1.
</span><span class="c"></span>
        <span class="c"># fib(n - 2)
</span><span class="c"></span>        <span class="c">#############################################################################
</span><span class="c"></span>        <span class="nf">addi</span>    <span class="no">a0</span><span class="p">,</span>  <span class="no">a0</span><span class="p">,</span> <span class="p">-</span><span class="mi">1</span>    <span class="c"># a0 &lt;- a0 - 1
</span><span class="c"></span>
        <span class="nf">addi</span>    <span class="no">sp</span><span class="p">,</span>  <span class="no">sp</span><span class="p">,</span> <span class="p">-</span><span class="mi">4</span>    <span class="c">#
</span><span class="c"></span>        <span class="no">sw</span>      <span class="no">t0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">(</span><span class="no">sp</span><span class="p">)</span>     <span class="c"># Push t0 onto the stack.
</span><span class="c"></span>
        <span class="nf">call</span>         <span class="no">_R_FIB</span>    <span class="c"># fib(n-1) gets loaded into a0
</span><span class="c"></span>
        <span class="nf">lw</span>      <span class="no">t0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">(</span><span class="no">sp</span><span class="p">)</span>     <span class="c"># Pop once for t0.
</span><span class="c"></span>        <span class="no">lw</span>      <span class="no">ra</span><span class="p">,</span>  <span class="mi">4</span><span class="p">(</span><span class="no">sp</span><span class="p">)</span>     <span class="c"># Once more for the return address.
</span><span class="c"></span>        <span class="no">addi</span>    <span class="no">sp</span><span class="p">,</span>  <span class="no">sp</span><span class="p">,</span> <span class="mi">8</span>     <span class="c">#
</span><span class="c"></span>        <span class="c">#############################################################################
</span><span class="c"></span>
        <span class="c"># At this point, a0 = fib(n-2) and t0 = fib(n-1)
</span><span class="c"></span>
        <span class="nf">add</span>     <span class="no">a0</span><span class="p">,</span> <span class="no">a0</span><span class="p">,</span> <span class="no">t0</span>     <span class="c">#
</span><span class="c"></span>        <span class="no">EXIT</span><span class="p">:</span> <span class="no">ret</span>              <span class="c"># return fib(n - 1) + fib(n - 2)
</span></code></pre></div><p>Not too bad when you break it down piece by piece. But, it certainly helps give
an appreciation for the amount of headache compilers save us.</p>
<h1 id="a-look-at-the-iterative-version">A look at the iterative version</h1>
<p>Now that we&rsquo;ve done this the hard way, let&rsquo;s take a look at the better approach.
Here is the same function but programmed iteratively.</p>
<div class="highlight"><pre class="chroma"><code class="language-asm" data-lang="asm"><span class="c"># Arguments: a0: int = n
</span><span class="c"># Returns:   a0: int = fib(n)
</span><span class="c"># Summary:   a0 &lt;- fib(a0)
</span><span class="c"></span><span class="nl">FIB:</span>
    <span class="nf">addi</span>    <span class="no">sp</span><span class="p">,</span>  <span class="no">sp</span><span class="p">,</span> <span class="p">-</span><span class="mi">4</span>    <span class="c">#
</span><span class="c"></span>    <span class="no">sw</span>      <span class="no">s0</span><span class="p">,</span>  <span class="mi">4</span><span class="p">(</span><span class="no">sp</span><span class="p">)</span>     <span class="c"># Push s0 to the stack.
</span><span class="c"></span>
    <span class="nf">li</span>      <span class="no">s0</span><span class="p">,</span>  <span class="no">s0</span><span class="p">,</span> <span class="mi">2</span>     <span class="c"># Constant used for comparisons.
</span><span class="c"></span>
    <span class="nf">blt</span>     <span class="no">a0</span><span class="p">,</span>  <span class="no">s0</span><span class="p">,</span> <span class="no">EXIT</span>  <span class="c"># If n &lt; 2, then fib(n) = n.
</span><span class="c"></span>
    <span class="nf">li</span>      <span class="no">t0</span><span class="p">,</span>  <span class="mi">1</span>    <span class="c"># Initialize N.
</span><span class="c"></span>    <span class="no">li</span>      <span class="no">t1</span><span class="p">,</span>  <span class="mi">1</span>    <span class="c"># fib(1) = 1
</span><span class="c"></span>    <span class="no">li</span>      <span class="no">t2</span><span class="p">,</span>  <span class="mi">0</span>    <span class="c"># fib(0) = 0
</span><span class="c"></span>
    <span class="nl">LOOP:</span>
         <span class="nf">addi</span><span class="p">,</span>   <span class="no">t0</span><span class="p">,</span>  <span class="no">t0</span><span class="p">,</span> <span class="mi">1</span>       <span class="c"># Increment counter.
</span><span class="c"></span>         <span class="no">mv</span>      <span class="no">t3</span><span class="p">,</span>  <span class="no">t1</span>          <span class="c"># Save fib(n-1) in temporary register.
</span><span class="c"></span>         <span class="no">add</span>     <span class="no">t1</span><span class="p">,</span>  <span class="no">t1</span><span class="p">,</span> <span class="no">t2</span>      <span class="c"># fib(n-1)[next] &lt;- fib(n-1)[curr] + fib(n-2)[curr]
</span><span class="c"></span>         <span class="no">mv</span>      <span class="no">t2</span><span class="p">,</span>  <span class="no">t3</span>          <span class="c"># fib(n-2)[next] &lt;- fib(n-1)[curr]
</span><span class="c"></span>         <span class="no">blt</span>     <span class="no">t0</span><span class="p">,</span>  <span class="no">a0</span><span class="p">,</span> <span class="no">LOOP</span>    <span class="c"># Loop again if counter &lt; n.
</span><span class="c"></span>
    <span class="nf">mv</span>      <span class="no">a0</span><span class="p">,</span>  <span class="no">t1</span>    <span class="c"># Move fib(n-1)[next] = fib(n)[curr] into return register.
</span><span class="c"></span>    <span class="no">EXIT</span><span class="p">:</span>   <span class="no">ret</span>        <span class="c"># Return.
</span></code></pre></div><p>It&rsquo;s more readable in my opinion. It has more going for
it than that, though.</p>
<ul>
<li>It has next to no memory accesses.</li>
<li>It has fewer <em>static</em> instructions (more on this in a second).</li>
<li>It&rsquo;s not vulnerable to a stack overflow for large values of <code>n</code>.</li>
</ul>
<p>It&rsquo;s difficult for me to come up with any advantages of the recursive
version other than it looks good in a high-level language. The most I can
say is that the difference in size is not as important as it seems at
first glance. Sure, the iterative version has fewer static instructions and
will therefore save you some space in your binary. But, as far as dynamic instructions
go, they&rsquo;ll be on the same order of magnitude.</p>
<p>What really hurts the recursive version is its excessive memory access. This is really
the key lesson to be learned from this exercise. This subroutine succinctly
demonstrates the overhead that is inherent to recursion and even function calls
in general. That&rsquo;s something to consider when writing recursive algorithms in the future.
Is your cache going to save you? Or will you suffer miss after miss, piling on 100s of
nanoseconds per call?</p>

    
    <div class="nav-next-prev">
        <div class="nav-prev">
            
                <a href="https://www.trmckay.com/posts/rsync-anacron-backups/"><i class="fas fa-chevron-left"></i></a>
            
        </div>
        <a class="nav-top" href="#">top</i></a>
        <div class="nav-next">
            
                <a class="grayed-out" href="javascript:void()"><i class="fas fa-chevron-right"></i></a>
            
        </div>
    </div>
    

            </div><footer>
<div class="footer-content">

  <div class="contact-info">
      
          <div class="footer-mail">
          <i class="far fa-envelope"></i> <a href="mailto:tm@trmckay.com">tm@trmckay.com</a> </div>
      
      
  </div>


<p class="copyright meta">Copyright © 2021, Trevor McKay</p>

</div>
</footer></main>
    </body>
    <script src=https://www.trmckay.com/js/navbutton.js></script>
</html>
